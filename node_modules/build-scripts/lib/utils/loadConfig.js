var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import path from 'path';
import fs from 'fs';
import fg from 'fast-glob';
import JSON5 from 'json5';
import { createRequire } from 'module';
import buildConfig from './buildConfig.js';
import dynamicImport from './dynamicImport.js';
const require = createRequire(import.meta.url);
export const mergeModeConfig = (mode, userConfig) => {
    // modify userConfig by userConfig.modeConfig
    if (userConfig.modeConfig &&
        mode &&
        userConfig.modeConfig[mode]) {
        const _a = userConfig.modeConfig[mode], { plugins } = _a, basicConfig = __rest(_a, ["plugins"]);
        const userPlugins = [...userConfig.plugins];
        if (Array.isArray(plugins)) {
            const pluginKeys = userPlugins.map((pluginInfo) => {
                return Array.isArray(pluginInfo) ? pluginInfo[0] : pluginInfo;
            });
            plugins.forEach((pluginInfo) => {
                const [pluginName] = Array.isArray(pluginInfo)
                    ? pluginInfo
                    : [pluginInfo];
                const pluginIndex = pluginKeys.indexOf(pluginName);
                if (pluginIndex > -1) {
                    // overwrite plugin info by modeConfig
                    userPlugins[pluginIndex] = pluginInfo;
                }
                else {
                    // push new plugin added by modeConfig
                    userPlugins.push(pluginInfo);
                }
            });
        }
        return Object.assign(Object.assign(Object.assign({}, userConfig), basicConfig), { plugins: userPlugins });
    }
    return userConfig;
};
export const getUserConfig = ({ rootDir, commandArgs, logger, pkg, configFile, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { config } = commandArgs;
    let configPath = '';
    if (config) {
        configPath = path.isAbsolute(config)
            ? config
            : path.resolve(rootDir, config);
    }
    else {
        const [defaultUserConfig] = yield fg(configFile, { cwd: rootDir, absolute: true });
        configPath = defaultUserConfig;
    }
    let userConfig = {
        plugins: [],
    };
    if (configPath && fs.existsSync(configPath)) {
        try {
            userConfig = yield loadConfig(configPath, pkg, logger);
        }
        catch (err) {
            logger.warn(`Fail to load config file ${configPath}`);
            if (err instanceof Error) {
                logger.error(err.stack);
            }
            else {
                logger.error(err.toString());
            }
            process.exit(1);
        }
    }
    else if (configPath) {
        // If path was not found
        logger.error(`config file${`(${configPath})` || ''} is not exist`);
        process.exit(1);
    }
    else {
        logger.debug('It\'s most likely you don\'t have a config file in root directory!\n' +
            'Just ignore this message if you know what you do; Otherwise, check it by yourself.');
    }
    return mergeModeConfig(commandArgs.mode, userConfig);
});
export function loadConfig(filePath, pkg, logger) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const start = Date.now();
        const isTypeModule = (pkg === null || pkg === void 0 ? void 0 : pkg.type) === 'module';
        const isJson = filePath.endsWith('.json');
        // The extname of files may `.mts|.ts`
        const isTs = filePath.endsWith('ts');
        const isJs = filePath.endsWith('js');
        const isESM = ['mjs', 'mts'].some((type) => filePath.endsWith(type))
            || (isTypeModule && ['js', 'ts'].some((type) => filePath.endsWith(type)));
        let userConfig;
        if (isJson) {
            return JSON5.parse(fs.readFileSync(filePath, 'utf8'));
        }
        // If config file respect ES module spec.
        if (isESM && isJs) {
            userConfig = (_a = (yield dynamicImport(filePath, true))) === null || _a === void 0 ? void 0 : _a.default;
        }
        // Config file respect CommonJS spec.
        if (!isESM && isJs) {
            userConfig = require(filePath);
        }
        if (isTs) {
            const code = yield buildConfig(filePath, isESM ? 'esm' : 'cjs');
            userConfig = yield executeTypescriptModule(code, filePath, isESM);
            logger.debug(`bundled module file loaded in ${Date.now() - start}m`);
        }
        return userConfig;
    });
}
function executeTypescriptModule(code, filePath, isEsm = true) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const tempFile = `${filePath}.${isEsm ? 'm' : 'c'}js`;
        let userConfig = null;
        fs.writeFileSync(tempFile, code);
        delete require.cache[require.resolve(tempFile)];
        try {
            const raw = isEsm ? (yield dynamicImport(tempFile, true)) : require(tempFile);
            userConfig = (_a = raw === null || raw === void 0 ? void 0 : raw.default) !== null && _a !== void 0 ? _a : raw;
        }
        catch (err) {
            fs.unlinkSync(tempFile);
            // Hijack error message
            if (err instanceof Error) {
                err.message = err.message.replace(tempFile, filePath);
                err.stack = err.stack.replace(tempFile, filePath);
            }
            throw err;
        }
        fs.unlinkSync(tempFile);
        return userConfig;
    });
}
